export default {
  cancel: {
    zh: '取消',
    en: 'Cancel',
    tr: 'İptal',
    ja: 'キャンセル',
    hu: 'Mégsem',
  },
  confirm: {
    zh: '确定',
    en: 'Confirm',
    tr: 'Onayla',
    ja: '確認',
    hu: 'Megerősít',
  },
  inputRequired: {
    zh: '请输入',
    en: 'Please input',
    tr: 'Lütfen girin',
    ja: '入力してください',
    hu: 'Kérjük adja meg',
  },
  selectRequired: {
    zh: '请选择',
    en: 'Please select',
    tr: 'Lütfen seçin',
    ja: '選択してください',
    hu: 'Kérjük válassza ki',
  },
  back: {
    zh: '返回',
    en: 'Back',
    tr: 'Geri',
    ja: '戻る',
    hu: 'Vissza',
  },
  save: {
    zh: '保 存',
    en: 'Save',
    tr: 'Kaydet',
    ja: '保存',
    hu: 'Mentés',
  },
  saveOnly: {
    zh: '仅保存',
    en: 'Save Only',
    tr: 'Sadece Kaydet',
    ja: '保存のみ',
    hu: 'Csak Mentés',
  },
  reset: {
    zh: '重置',
    en: 'Reset',
    tr: 'sıfırlama',
    ja: 'リセット',
    hu: 'átszed',
  },
  disable: {
    zh: '禁用',
    en: 'Disable',
    tr: 'Devre dışı bırakmak',
    ja: '無効にする',
    hu: 'Letiltás',
  },
  enable: {
    zh: '启用',
    en: 'Enable',
    tr: 'Etkinleştirme',
    ja: '有効',
    hu: 'Engedélyezze',
  },
  noData: {
    zh: '暂无数据',
    en: 'No Data',
    tr: 'Veri yok',
    ja: 'データなし',
    hu: 'Nincs adat',
  },
  createSuccess: {
    zh: '创建成功',
    en: 'Create Success',
    tr: 'Kayıt Edildi',
    ja: '新規に成功しました',
    hu: 'Sikeresen létrehozva',
  },
  createfailed: {
    zh: '创建失败',
    en: 'Create Failed',
    tr: 'Kayıt Edilemedi',
    ja: '新規に失敗しました',
    hu: 'Sikertelen létrehozás',
  },
  editSuccess: {
    zh: '编辑成功',
    en: 'Edit Success',
    tr: 'Düzenlendi',
    ja: '更新に成功しました',
    hu: 'Sikeres szerkeztés',
  },
  editfailed: {
    zh: '编辑失败',
    en: 'Edit Failed',
    tr: 'Düzenlenemedi',
    ja: '更新に失敗しました',
    hu: 'Sikertelen szerkeztés',
  },
  deleteSuccess: {
    zh: '删除成功',
    en: 'Delete Success',
    tr: 'Silindi',
    ja: '削除に成功しました',
    hu: 'Sikeres törlés',
  },
  deletefailed: {
    zh: '删除失败',
    en: 'Delete Failed',
    tr: 'Silinemedi',
    ja: '削除に失敗しました',
    hu: 'Sikertelen törlés',
  },
  saveSuccess: {
    zh: '保存成功',
    en: 'Save Success',
    tr: 'Kaydetme Başarılı',
    ja: '保存に成功しました',
    hu: 'Sikeres mentés',
  },
  warning: {
    zh: '提示',
    en: 'Warning',
    tr: 'Uyarı',
    ja: 'ワーニング',
    hu: 'Figyelem',
  },
  confirmDelete: {
    zh: '此操作将删除 {name}，是否继续？',
    en: 'This will delete {name}, continue?',
    tr: '{name} silinecek, devam edilsin mi?',
    ja: '該当操作は{name}を削除してもよろしいですか？',
    hu: '{name} törlésre fog kerülni, folytatja?',
  },
  confirmReset: {
    zh: '此操作将重置发送时的属性配置，是否继续？',
    en: 'This will reset properties, continue?',
    tr: 'Bu, özellikleri sıfırlayacak, devam edilsin mi?',
    ja: '該当操作はpropertiesを削除してもよろしいですか？',
    hu: 'Ez visszaállítja a tulajdonságokat, folytatja?',
  },
  new: {
    zh: '新 建',
    en: 'New',
    tr: 'Yeni',
    ja: '新 規',
    hu: 'Új',
  },
  delete: {
    zh: '删 除',
    en: 'Delete',
    tr: 'Sil',
    ja: '削 除',
    hu: 'Törlés',
  },
  edit: {
    zh: '编 辑',
    en: 'Edit',
    tr: 'Düzenle',
    ja: '編 集',
    hu: 'Szerkesztés',
  },
  unitS: {
    zh: '秒',
    en: 's',
    tr: 's',
    ja: '秒',
    hu: 's',
  },
  unitMS: {
    zh: '毫秒',
    en: 'ms',
    tr: 'ms',
    ja: 'ミリ秒',
    hu: 'ms',
  },
  config: {
    zh: '编辑连接',
    en: 'Edit Connection',
    tr: 'Bağlantıyı Düzenle',
    ja: '接続の編集',
    hu: 'Kapcsolat szerkesztése',
  },
  copy: {
    zh: '复 制',
    en: 'Copy',
    tr: 'Kopyala',
    ja: 'コピー',
    hu: 'Másolás',
  },
  copySuccess: {
    zh: '复制成功',
    en: 'Copy Success',
    tr: 'Kopyalandı',
    ja: 'コピーが成功しました',
    hu: 'Sikeres másolás',
  },
  copied: {
    zh: '已复制',
    en: 'Copied',
    tr: 'Kopyalandı',
    ja: 'コピー済み',
    hu: 'Másolva',
  },
  copyFailed: {
    zh: '复制失败',
    en: 'Copy Failed',
    tr: 'Kopyalanamadı',
    ja: 'コピーが失敗しました',
    hu: 'Sikertelen másolás',
  },
  exportSuccess: {
    zh: '导出成功',
    en: 'exported successfully',
    tr: 'başarıyla dışa aktarıldı',
    ja: 'のエクスポートが成功しました',
    hu: 'Sikeres exportálás',
  },
  importSuccess: {
    zh: '导入成功',
    en: 'Imported successfully',
    tr: 'Başarıyla içe aktarıldı',
    ja: 'インポートが成功しました',
    hu: 'Sikeres importálás',
  },
  newWindow: {
    zh: '新建窗口',
    en: 'New Window',
    tr: 'Yeni pencere',
    ja: '新しいウィンドウ',
    hu: 'Új ablak',
  },
  version: {
    zh: '版本：',
    en: 'Version: ',
    tr: 'Versiyon: ',
    ja: 'システムバージョン：',
    hu: 'Verzió: ',
  },
  uptime: {
    zh: '运行时间：',
    en: 'Uptime: ',
    tr: 'Çalışma süresi: ',
    ja: '稼働時間：',
    hu: 'Futásidő: ',
  },
  emqx: {
    zh: '想要部署一个自托管的 MQTT 服务，试试 {emqx} 吧。',
    en: 'To deploy a self-managed MQTT Broker, try {emqx}.',
    tr: "Kendi yönettiğiniz bir MQTT Broker'a sahip olmak için {emqx}'i deneyin.",
    ja: '自己管理型のMQTT Brokerをデプロイするには、{emqx}を試してください。',
    hu: 'Próbálja ki a saját maga kezelésében lévő MQTT Broker telepítését a {emqx} segítségével.',
  },
  cloud: {
    zh: '需要一个云原生的全托管 MQTT 服务？一键部署 {cloud}！',
    en: 'Need a fully managed MQTT cloud service? Try {cloud} Now!',
    tr: "Tamamen yönetilen bir MQTT bulut hizmetine mi ihtiyacınız var? {cloud}'i şimdi deneyin!",
    ja: '完全に管理されたMQTTクラウドサービスが必要ですか？今すぐ{cloud}を試してください！',
    hu: 'Szüksége van egy teljesen kezelt MQTT felhőszolgáltatásra? Próbálja ki most a {cloud}!',
  },
  duplicate: {
    zh: '复制连接',
    en: 'Duplicate',
    tr: 'Kopyala',
    ja: '複製',
    hu: 'Másol',
  },
  neverExpire: {
    zh: '永不过期',
    en: 'Never Expire',
    tr: 'Süresiz',
    ja: '期限なし',
    hu: 'Soha ne járjon le',
  },
  newMsg: {
    zh: '{count} 条新消息 | {count} 条新消息',
    en: '{count} new message | {count} new messages',
    tr: '{count} yeni mesaj | {count} yeni mesaj',
    ja: '{count}件の新しいメッセージ | {count}件の新しいメッセージ',
    hu: '{count} új üzenet | {count} új üzenet',
  },
  thinking: {
    zh: '思考中...',
    en: 'Thinking...',
    tr: 'Düşünüyorum...',
    ja: '考え中...',
    hu: 'Gondolkodom...',
  },
  welcomeToCopilot: {
    zh: '您好！我是 MQTTX Copilot 🤖，一个专门设计来帮助解答 MQTT 相关问题，提供常见问题的解决方案，并提供最佳实践见解的 AI 助手。今天我能如何帮助您？',
    en: 'Hello! I am MQTTX Copilot 🤖, an AI assistant designed to help with MQTT-related queries, provide solutions for common issues, and offer insights on best practices. How can I assist you today?',
    tr: 'Merhaba! Ben MQTTX Copilot 🤖, MQTT ile ilgili sorgulara yardımcı olmak, yaygın sorunlar için çözümler sağlamak ve en iyi uygulamalar hakkında bilgi vermek üzere tasarlanmış bir AI asistanıyım. Bugün size nasıl yardımcı olabilirim?',
    ja: 'こんにちは！私は MQTTX Copilot 🤖、MQTT 関連の問い合わせを支援し、一般的な問題の解決策を提供し、ベストプラクティスについての洞察を提供するために設計された AI アシスタントです。今日は何でお手伝いでしょうか？',
    hu: 'Szia! Én vagyok az MQTTX Copilot 🤖, egy AI asszisztens, amelyet az MQTT-vel kapcsolatos kérdések megválaszolására, a gyakori problémák megoldására és a legjobb gyakorlatok bemutatására terveztek. Hogyan segíthetek ma?',
  },
  copiltePubMsgPlacehoder: {
    zh: '向 MQTTX Copilot 发送消息...',
    en: 'Message MQTTX Copilot...',
    tr: "MQTTX Copilot'a mesaj gönder...",
    ja: 'MQTTX Copilotにメッセージを送る...',
    hu: 'Üzenet küldése a MQTTX Copilotnak...',
  },
  copilteUser: {
    zh: '用户',
    en: 'You',
    tr: 'Sen',
    ja: 'あなた',
    hu: 'Te',
  },
  copilotAPIKeyRequired: {
    zh: '请先在设置中配置 Copilot 的 API Key',
    en: 'Please configure the Copilot API Key in the settings first',
    tr: 'Lütfen önce ayarlarda Copilot API Anahtarını yapılandırın',
    ja: '最初に設定でCopilot APIキーを構成してください',
    hu: 'Kérjük, először állítsa be a Copilot API-kulcsot a beállításokban',
  },
  goToSetting: {
    zh: '去设置',
    en: 'Go Settings',
    tr: 'Ayarlar',
    ja: '設定',
    hu: 'Beállítások',
  },
  promptError: {
    zh: '请帮助解析并解决以下错误：',
    en: 'Please help to analyze and resolve the following error: ',
    tr: 'Lütfen aşağıdaki hata mesajını analiz etmeye ve çözmeye yardımcı olun: ',
    ja: '以下のエラーメッセージを分析し、解決してください：',
    hu: 'Kérjük, segítsen elemezni és megoldani az alábbi hibaüzenetet: ',
  },
  myConnectionInfo: {
    zh: '有需要的话可以查看这个当前的连接信息：@connection',
    en: 'If needed, you can check the current connection information: @connection',
    tr: 'Gerekirse, mevcut bağlantı bilgisini kontrol edebilirsiniz: @connection',
    ja: '必要な場合は、現在の接続情報を確認できます：@connection',
    hu: 'Szükség esetén ellenőrizheti a jelenlegi kapcsolati információkat: @connection',
  },
  promptCodegen: {
    zh: '客户端代码生成',
    en: 'Client Codegen',
    tr: 'Kod Oluşturucu',
    ja: 'コード生成',
    hu: 'Kódgenerálás',
  },
  promptProgrammingLanguage: {
    zh: '使用当前连接创建 {0} MQTT Client 代码 {1}，如果使用了 MQTT5 的，注意配置属性',
    en: 'Create {0} MQTT Client code with the current connection {1}, if you use MQTT5, pay attention to the configuration properties',
    tr: 'Mevcut bağlantı ile {0} MQTT Client kodu oluştur {1}, MQTT5 kullanıyorsanız, yapılandırma özelliklerine dikkat edin',
    ja: '現在の接続で {0} MQTTクライアントコードを作成する {1}，MQTT5を使用する場合は、構成プロパティに注意してください',
    hu: 'Hozzon létre {0} MQTT ügyfélkódot az aktuális kapcsolattal {1}, ha MQTT5-öt használ, figyeljen a konfigurációs tulajdonságokra',
  },
  genSimpleIoTPayload: {
    zh: '生成简单测试数据',
    en: 'Generate Simple Test Data',
    tr: 'Basit IoT Verisi Oluştur',
    ja: 'シンプルなIoTデータを生成する',
    hu: 'Egyszerű IoT Adatok Generálása',
  },
  promptGenSimpleIoTPayload: {
    zh: '生成简单结构的 MQTT IoT 测试数据，适合基础测试场景。',
    en: 'Generate MQTT IoT test data with a simple structure, suitable for basic testing scenarios.',
    tr: 'Temel test senaryoları için basit yapıda MQTT IoT test verileri oluşturun.',
    ja: '基本的なテストシナリオに適した、単純な構造のMQTT IoTテストデータを生成します。',
    hu: 'Generáljon egyszerű szerkezetű MQTT IoT tesztadatokat, amelyek alapvető tesztelési forgatókönyvekhez alkalmasak.',
  },
  genComplexIoTPayload: {
    zh: '生成复杂测试数据',
    en: 'Generate Complex Test Data',
    tr: 'Karmaşık IoT Verisi Oluştur',
    ja: '複雑なIoTデータを生成する',
    hu: 'Bonyolult IoT Adatok Generálása',
  },
  promptGenComplexIoTPayload: {
    zh: '生成具有复杂结构的 MQTT IoT 测试数据，适用于高级测试场景，包括多设备交互和数据分析。',
    en: 'Generate MQTT IoT test data with a complex structure, suitable for advanced testing scenarios, including multi-device interactions and data analysis.',
    tr: 'Gelişmiş test senaryoları için uygun, çoklu cihaz etkileşimlerini ve veri analizini içeren karmaşık yapıda IoT test verileri oluşturun.',
    ja: '複数デバイスの相互作用とデータ分析を含む、高度なテストシナリオに適した複雑な構造のIoTテストデータを生成します。',
    hu: 'Generáljon bonyolult szerkezetű IoT tesztadatokat, amelyek alkalmasak fejlett tesztelési forgatókönyvekre, beleértve a több eszköz közötti interakciókat és az adatelemzést.',
  },
  genConnectedCarPayload: {
    zh: '车联网测试数据',
    en: 'Connected Car Test Data',
    tr: 'Bağlantılı Araba Test Verisi Oluştur',
    ja: 'コネクテッドカーのテストデータを生成する',
    hu: 'Csatlakoztatott Autó Tesztadatok Generálása',
  },
  promptGenConnectedCarPayload: {
    zh: '生成车联网测试数据，模拟车辆通信、远程监控和数据分析。',
    en: 'Generate connected car test data, simulating vehicle communication, remote monitoring, and data analysis.',
    tr: 'Araç iletişimi, uzaktan izleme ve veri analizini simüle eden bağlantılı araba test verileri oluşturun.',
    ja: '車両通信、リモートモニタリング、データ分析をシミュレートするコネクテッドカーのテストデータを生成します。',
    hu: 'Generáljon csatlakoztatott autó tesztadatokat, amelyek az autókommunikációt, a távoli monitorozást és az adatelemzést szimulálják.',
  },
  genSmartHomePayload: {
    zh: '智能家居测试数据',
    en: 'Smart Home Test Data',
    tr: 'Akıllı Ev Test Verisi Oluştur',
    ja: 'スマートホームのテストデータを生成する',
    hu: 'Okosotthoni Tesztadatok Generálása',
  },
  promptGenSmartHomePayload: {
    zh: '生成智能家居测试数据，包括设备自动化和用户行为模式。',
    en: 'Generate smart home test data, covering device automation and user behavior patterns.',
    tr: 'Cihaz otomasyonunu ve kullanıcı davranış modellerini içeren akıllı ev test verileri oluşturun.',
    ja: 'デバイスの自動化とユーザー行動パターンを含むスマートホームテストデータを生成します。',
    hu: 'Generáljon okosotthoni tesztadatokat, amelyek az eszközautomatizálást és a felhasználói viselkedésmintákat tartalmazzák.',
  },
  genIndustrialIoTPayload: {
    zh: '工业物联网测试数据',
    en: 'Industrial IoT Test Data',
    tr: 'Endüstriyel IoT Test Verisi Oluştur',
    ja: '産業用IoTテストデータを生成する',
    hu: 'Ipari IoT Tesztadatok Generálása',
  },
  promptGenIndustrialIoTPayload: {
    zh: '生成适用于工业物联网场景的 MQTT IoT 测试数据，包括机器性能、传感器读数和生产线状态。',
    en: 'Generate MQTT IoT test data suitable for industrial IoT scenarios, including machine performance, sensor readings, and production line statuses.',
    tr: 'Makine performansını, sensör okumalarını ve üretim hattı durumlarını içeren, endüstriyel IoT senaryoları için uygun MQTT IoT test verileri oluşturun.',
    ja: '機械のパフォーマンス、センサーの読み取り、生産ラインの状態を含む、産業用IoTシナリオに適したMQTT IoTテストデータを生成します。',
    hu: 'Generáljon MQTT IoT tesztadatokat ipari IoT forgatókönyvekhez, beleértve a gépek teljesítményét, a szenzorok olvasásait és a termelési sor állapotait.',
  },
  genPayloadFormat: {
    zh: '请确保给我一个包含必要信息的完整的 JSON 数据，不需要其它额外信息。这个 JSON 数据应该包含模拟的基础信息，适合基础测试场景，并且可以包含简单的数据结构的介绍。',
    en: 'Please make sure to give me a complete JSON data containing the necessary information, no other additional information is required. This JSON data should contain simulated basic information, suitable for basic testing scenarios, and can contain an introduction to simple data structures.',
    tr: 'Lütfen bana gerekli bilgileri içeren tam bir JSON verisi verdiğinizden emin olun, başka ek bilgi gerekmez. Bu JSON verileri, temel test senaryoları için uygun, simüle edilmiş temel bilgileri içermeli ve basit veri yapılarına bir giriş içerebilir.',
    ja: '必要な情報を含む完全なJSONデータを提供してください。他に追加情報は必要ありません。このJSONデータには、基本的なテストシナリオに適したシミュレートされた基本情報が含まれており、単純なデータ構造の紹介を含む場合があります。',
    hu: 'Győződjön meg róla, hogy ad nekem egy teljes JSON adatot, amely tartalmazza a szükséges információkat, más további információ nem szükséges. Ez a JSON adat tartalmazhat szimulált alapinformációkat, amelyek alkalmasak az alapvető tesztelési forgatókönyvekre, és tartalmazhatnak egy bevezetést az egyszerű adatszerkezetekhez.',
  },
  mqttProtocol: {
    zh: 'MQTT 协议是什么',
    en: 'What is MQTT Protocol',
    tr: 'MQTT Protokolü Nedir',
    ja: 'MQTTプロトコルとは何ですか',
    hu: 'Mi az MQTT protokoll',
  },
  whatIsMQTT5: {
    zh: 'MQTT 5.0 是什么',
    en: 'What is MQTT 5.0',
    tr: 'MQTT 5.0 nedir',
    ja: 'MQTT 5.0 とは何ですか',
    hu: 'Mi az MQTT 5.0',
  },
  whatIsMQTT5Desc: {
    zh: 'MQTT 5.0 是什么？请提供详细的介绍，包含 MQTT 5.0 的新特性和更新。',
    en: 'What is MQTT 5.0? Please provide a detailed introduction, including the new features and updates of MQTT 5.0.',
    tr: "MQTT 5.0 nedir? Lütfen MQTT 5.0'ın yeni özelliklerini ve güncellemelerini içeren ayrıntılı bir tanıtım sağlayın.",
    ja: 'MQTT 5.0とは何ですか？MQTT 5.0の新機能と更新を含む詳細な紹介を提供してください。',
    hu: 'Mi az MQTT 5.0? Kérjük, adjon meg egy részletes bevezetést, amely tartalmazza az MQTT 5.0 új funkcióit és frissítéseit.',
  },
  mqttQoS: {
    zh: 'MQTT QoS 是什么',
    en: 'What is MQTT QoS',
    tr: 'MQTT QoS Nedir',
    ja: 'MQTT QoSとは何ですか',
    hu: 'Mi az MQTT QoS',
  },
  mqttQoSDesc: {
    zh: 'MQTT QoS 是什么？我该如何选择，请提供一些真实场景案例区分',
    en: 'What is MQTT QoS? How do I choose? Please provide some real-world scenario cases to distinguish',
    tr: 'MQTT QoS Nedir? Nasıl seçilir? Lütfen ayırt etmek için bazı gerçek dünya senaryo durumları sağlayın',
    ja: 'MQTT QoSとは何ですか？どうやって選びますか？区別するためにいくつかの実世界のシナリオケースを提供してください',
    hu: 'Mi az MQTT QoS? Hogyan válasszam ki? Kérjük, adjon meg néhány valós világ szcenárió esetet a megkülönböztetéshez',
  },
  mqttRetain: {
    zh: 'MQTT 保留消息是什么',
    en: "What's the Retain Message",
    tr: 'Retain Mesajı Nedir',
    ja: 'レテインメッセージとは何ですか',
    hu: 'Mi a Retain Üzenet',
  },
  mqttRetainDesc: {
    zh: 'MQTT 保留消息是什么？我该如何使用，请提供一些真实场景案例，并且告知如何使用 MQTTX 来清除保留消息呢？',
    en: "What's the MQTT Retain Message? How do I use it? Please provide some real-world scenario cases and tell me how to use MQTTX to clear retained messages?",
    tr: "MQTT Retain Mesajı Nedir? Nasıl kullanılır? Lütfen bazı gerçek dünya senaryo durumları sağlayın ve MQTTX'i kullanarak kalıcı mesajları nasıl temizleyeceğimi söyleyin?",
    ja: 'MQTT レテインメッセージとは何ですか？どうやって使うのですか？実際のシナリオケースをいくつか提供し、MQTTXを使用して保持されたメッセージをクリアする方法を教えてください。',
    hu: 'Mi az MQTT Retain Üzenet? Hogyan használjam? Kérjük, adjon meg néhány valós világ szcenárió esetet, és mondja el, hogyan használhatom az MQTTX-et a megőrzött üzenetek törléséhez?',
  },
  installEMQX: {
    zh: '如何安装 EMQX',
    en: 'How to install EMQX',
    tr: 'EMQX Nasıl Kurulur',
    ja: 'EMQXのインストール方法',
    hu: 'Hogyan telepíthető az EMQX',
  },
  emqxRule: {
    zh: 'EMQX 规则引擎 SQL 示例',
    en: 'EMQX Rule Engine SQL Example',
    tr: 'EMQX Kural Motoru SQL Örneği',
    ja: 'EMQXルールエンジンSQLの例',
    hu: 'EMQX szabálymotor SQL példa',
  },
  promptEmqxRule: {
    zh: '请帮我编辑一段 EMQX 规则引擎的 SQL 示例，包含解释和简单教程',
    en: 'Please help me edit an EMQX Rule Engine SQL example, including explanation and simple tutorial',
    tr: 'Lütfen bana bir EMQX Kural Motoru SQL örneği düzenleme konusunda yardımcı olun, açıklama ve basit bir öğretici içerir',
    ja: 'EMQXルールエンジンSQLの例を編集してください。説明と簡単なチュートリアルが含まれています',
    hu: 'Segítsen szerkeszteni egy EMQX szabálymotor SQL példát, beleértve a magyarázatot és az egyszerű útmutatót',
  },
  currentConnectionInfo: {
    zh: '当前连接信息',
    en: 'Current Connection Info',
    tr: 'Mevcut Bağlantı Bilgisi',
    ja: '現在の接続情報',
    hu: 'Jelenlegi kapcsolat információ',
  },
  promptCurrentConnectionInfo: {
    zh: '请帮我解释当前连接的信息，包含连接的基本信息 {0}',
    en: 'Please help me explain the information of the current connection, including the basic information of the connection {0}',
    tr: 'Lütfen bana mevcut bağlantının bilgisini açıklama konusunda yardımcı olun, bağlantının temel bilgilerini içerir {0}',
    ja: '現在の接続の情報を説明してください。接続の基本情報を含みます {0}',
    hu: 'Segítsen elmagyarázni a jelenlegi kapcsolat adatait, beleértve a kapcsolat alapadatait {0}',
  },
  explainer: {
    zh: '解释器',
    en: 'Explainer',
    tr: 'Açıklayıcı',
    ja: '解説者',
    hu: 'Magyarázó',
  },
  insertCodeToEditor: {
    zh: '插入编辑器',
    en: 'Insert',
    tr: 'Ekle',
    ja: '挿入',
    hu: 'Beszúrás',
  },
  insertCodeSuccess: {
    zh: '代码已插入编辑器中',
    en: 'Code has been inserted into the editor',
    tr: 'Kod editöre eklendi',
    ja: 'コードがエディタに挿入されました',
    hu: 'A kód be lett szúrva a szerkesztőbe',
  },
  genTestDoc: {
    zh: '生成测试文档',
    en: 'Generate Test Document',
    tr: 'Test Belgesi Oluştur',
    ja: 'テストドキュメントを生成する',
    hu: 'Teszt dokumentum generálása',
  },
  promptGenTestDoc: {
    zh: '请帮我生成一份 MQTT的测试文档，包含测试的基本信息 {0}，并总结一份完整的测试报告',
    en: 'Please help me generate a MQTT connection test document, including the basic information of the test {0}, and summarize a complete test report',
    tr: 'Lütfen bana MQTT bağlantı testi belgesi oluşturma konusunda yardımcı olun, testin temel bilgilerini içerir {0} ve tam bir test raporu özetleyin',
    ja: 'MQTT接続テストドキュメントを生成してください。テストの基本情報を含みます {0} そして完全なテストレポートをまとめる',
    hu: 'Segítsen létrehozni egy MQTT kapcsolat teszt dokumentumot, beleértve a teszt alapvető információit {0} és összefoglal egy teljes teszt jelentést',
  },
  emqxLogAnalysis: {
    zh: 'EMQX 日志分析',
    en: 'EMQX Log Analysis',
    tr: 'EMQX Günlük Analizi',
    ja: 'EMQXログ分析',
    hu: 'EMQX naplóelemzés',
  },
  promptEmqxLogAnalysis: {
    zh: '请帮我分析一份 EMQX 日志，包含解释告警和错误信息等，并提供解决方案，日志内容：',
    en: 'Please help me analyze an EMQX log, including explanations of alerts and error messages, and provide solutions, log content:',
    tr: 'Lütfen bana bir EMQX günlüğü analiz etme konusunda yardımcı olun, uyarıların ve hata mesajlarının açıklamalarını içerir ve çözümler sağlar, günlük içeriği:',
    ja: 'EMQXログを分析してください。アラートとエラーメッセージの説明を含み、解決策を提供します。ログの内容',
    hu: 'Segítsen elemzeni egy EMQX naplót, beleértve az riasztások és hibaüzenetek magyarázatát, és megoldásokat nyújt, naplótartalom:',
  },
  programmingLang: {
    zh: '编程语言',
    en: 'Languages',
    tr: 'Diller',
    ja: 'プログラミング言語',
    hu: 'Programozási',
  },
  hardware: {
    zh: '硬件',
    en: 'Hardware',
    tr: 'Donanım',
    ja: 'ハードウェア',
    hu: 'Hardver',
  },
  mobileApps: {
    zh: '移动应用',
    en: 'Mobile Apps',
    tr: 'Mobil Uygulamalar',
    ja: 'モバイルアプリ',
    hu: 'Mobil alkalmazások',
  },
  webApps: {
    zh: 'Web 应用',
    en: 'Web Apps',
    tr: 'Web Uygulamalar',
    ja: 'Webアプリ',
    hu: 'Web alkalmazások',
  },
  seeMore: {
    zh: '查看更多',
    en: 'See More',
    tr: 'Daha Fazla',
    ja: 'もっと見る',
    hu: 'Továbbiak',
  },
  viewData: {
    zh: '查看数据',
    en: 'View Data',
    tr: 'Veriyi Görüntüle',
    ja: 'データを表示',
    hu: 'Adatok meg',
  },
  saveToLocal: {
    zh: '保存到本地',
    en: 'Save to Local',
    tr: 'Yerel olarak kaydet',
    ja: 'ローカルに保存',
    hu: 'Mentés helyi',
  },
  msgType: {
    zh: '消息类型',
    en: 'Message Type',
    tr: 'Mesaj Türü',
    ja: 'メッセージタイプ',
    hu: 'Üzenet típus',
  },
  last5Minutes: {
    zh: '最近 5 分钟',
    en: 'Last 5 Minutes',
    tr: 'Son 5 Dakika',
    ja: '最近 5分間',
    hu: 'Utoljára 5 perc',
  },
  last30Minutes: {
    zh: '最近 30 分钟',
    en: 'Last 30 Minutes',
    tr: 'Son 30 Dakika',
    ja: '最近 30 分間',
    hu: 'Utoljára 30 perc',
  },
  lastHour: {
    zh: '最近 1 小时',
    en: 'Last 1 Hour',
    tr: 'Son 1 Saat',
    ja: '最近 1 時間',
    hu: 'Utoljára 1 óra',
  },
  lastDay: {
    zh: '最近 1 天',
    en: 'Last 1 Day',
    tr: 'Son 1 Gün',
    ja: '最近 1 日',
    hu: 'Utoljára 1 nap',
  },
  lastWeek: {
    zh: '最近 1 周',
    en: 'Last 1 Week',
    tr: 'Son 1 Hafta',
    ja: '最近 1 週間',
    hu: 'Utoljára 1 hét',
  },
  startTime: {
    zh: '开始时间',
    en: 'Start Time',
    tr: 'Başlangıç Zamanı',
    ja: '開始時間',
    hu: 'Kezdés időpontja',
  },
  endTime: {
    zh: '结束时间',
    en: 'End Time',
    tr: 'Bitiş Zamanı',
    ja: '終了時間',
    hu: 'Befejezés időpontja',
  },
  customFunction: {
    zh: '自定义函数',
    en: 'Custom Function',
    tr: 'Özel Fonksiyon',
    ja: 'カスタム関数',
    hu: 'Egyedi függvény',
  },
  customRequirementGenerate: {
    zh: '自定义需求生成',
    en: 'Custom Requirement Generate',
    tr: 'Özel İhtiyaç Oluşturma',
    ja: 'カスタム要求生成',
    hu: 'Egyedi igény generálás',
  },
  simulateWeatherData: {
    zh: '模拟天气数据',
    en: 'Simulate Weather Data',
    tr: 'Hava Verisi Simüle Et',
    ja: '天気データをシミュレート',
    hu: 'Időjárás adatok szimulálása',
  },
  dynamicCommandSwitch: {
    zh: '动态指令切换',
    en: 'Dynamic Command Switch',
    tr: 'Dinamik Komut Anahtarı',
    ja: 'ダイナミックコマンドスイッチ',
    hu: 'Dinamik parancs kapcsoló',
  },
  timeFormatProcessing: {
    zh: '时间格式处理',
    en: 'Time Format Processing',
    tr: 'Zaman Formatı İşleme',
    ja: '時間フォーマット処理',
    hu: 'Időformátum feldolgozás',
  },
  promptCustomFunction: {
    zh: `请根据所选模式生成 MQTTX 自定义函数，并且给出原始 Payload 样本和预期结果：
      【生成模式】
        - 预设模板快速生成
        - 自定义需求生成（描述需求）
        ==== 预设模板库 ====
        01 模拟天气数据
        │ 参数格式：{ "temperature":[10,30], "humidity":[20,40] }
        │ 功能：为指定字段生成随机数值
        02 动态指令切换
        │ 参数格式：{ "field": "command", "values": ["on","off"] }
        │ 功能：根据消息索引交替改变指定字段值
        03 时间格式处理
        │ 参数格式：{ "timeField":"timestamp", "timezone":8 }
        │ 功能：将Unix时间戳转为UTC时间字符串
        ==== 自定义模式 ====
        【功能描述】
        详细说明需要实现的处理逻辑（如："给返回数据附带当前时间戳"）
        【输入示例】
        原始 Payload 样本：
        { 
          "temperature": 25, 
          "humidity": 50 
        }
        【输出要求】
        期望处理结果：
        { 
          "temperature": 25, 
          "humidity": 50, 
          "currentTime": "2023-10-21T14:30:00.000Z"
        }
        ==== 通用脚本框架 ====
        /**
         * @description {功能名称}
         * @param {object|string} value - 原始数据（自动解析JSON字符串）
         * @param {'publish'|'received'} msgType - 消息类型，值为 'received' 或 'publish'
         * @param {number} [index] - 消息索引，仅在脚本用于发布消息且启用定时消息时有效
         */
        function handlePayload(value, msgType, index) {
          try {
            // 核心处理逻辑 ▼▼▼
            {{CORE_LOGIC}}
            // 返回前处理（保持JSON序列化）
            return typeof _value === 'object' ? 
              JSON.stringify(_value, null, 2) : _value;
          } catch (e) {
            console.error('处理错误:', e);
            return value; // 保持原始数据不变
          }
        }
        execute(handlePayload);
        ==== 生成规则 ====
        1. 每个字段修改添加注释说明
        2. 严格区分消息流向处理逻辑
        3. 生成模拟数据时，为数值字段添加合理的波动
        4. 兼容旧版本的浏览器，不要使用过于新的 JavaScript 特性
        5. 按照自定义函数、原始 Payload 样本和预期结果的顺序提供，确保使用代码块格式
        6. 简练回答，避免冗长描述，但确保信息完整`,
    en: `Please generate MQTTX custom function based on selected mode, and provide test cases with expected results:
       [Generation Modes]
        - Preset template quick generation
        - Custom requirement generation (describe requirements)
        ==== Preset Templates ====
        01 Simulate Weather Data
        │ Parameter format: { "temperature":[10,30], "humidity":[20,40] }
        │ Function: Generate random values for specified fields
        02 Dynamic Command Switching
        │ Parameter format: { "field": "command", "values": ["on","off"] }
        │ Function: Alternately change specified field value based on message index
        03 Time Format Processing
        │ Parameter format: { "timeField":"timestamp", "timezone":8 }
        │ Function: Convert Unix timestamp to UTC time string
        ==== Custom Mode ====
        [Function Description]
        Detail the processing logic to implement (e.g.: "Add current timestamp to response data")
        [Input Example]
        Original Payload sample:
        { 
          "temperature": 25, 
          "humidity": 50 
        }
        [Output Requirements]
        Expected processed result:
        { 
          "temperature": 25, 
          "humidity": 50, 
          "currentTime": "2023-10-21T14:30:00.000Z"
        }
        ==== Script Framework ====
        /**
         * @description {Function Name}
         * @param {object|string} value - Raw data (auto-parse JSON string)
         * @param {'publish'|'received'} msgType - Message type: 'received' or 'publish'
         * @param {number} [index] - Message index (valid only when script used for publishing with scheduled message)
         */
        function handlePayload(value, msgType, index) {
          try {
            // Core processing logic ▼▼▼
            {{CORE_LOGIC}}
            // Pre-return processing (keep JSON serialized)
            return typeof _value === 'object' ? 
              JSON.stringify(_value, null, 2) : _value;
          } catch (e) {
            console.error('Processing error:', e);
            return value; // Keep original data
          }
        }
        execute(handlePayload);
        ==== Generation Rules ====
        1. Add comments for each field modification
        2. Strictly differentiate message flow handling logic
        3. Add reasonable fluctuation when generating mock data
        4. Maintain compatibility with older browsers (avoid latest JS features)
        5. Provide in the order of custom function, original Payload sample, and expected result, ensuring code block format
        6. Be concise in response, avoid lengthy descriptions, but ensure information completeness`,
    tr: `Lütfen seçilen moda göre MQTTX özel işlevi oluşturun ve beklenen sonuçlarla test durumlarını sağlayın:
       [Oluşturma Modları]
        - Önceden ayarlanmış şablon hızlı oluşturma
        - Özel gereksinim oluşturma (gereksinimleri tanımlayın)
        ==== Önceden Ayarlanmış Şablonlar ====
        01 Hava Durumu Verilerini Simüle Et
        │ Parametre formatı: { "temperature":[10,30], "humidity":[20,40] }
        │ İşlev: Belirtilen alanlar için rastgele değerler oluşturma
        02 Dinamik Komut Değiştirme
        │ Parametre formatı: { "field": "command", "values": ["on","off"] }
        │ İşlev: Mesaj dizinine göre belirtilen alan değerini dönüşümlü olarak değiştirme
        03 Zaman Formatı İşleme
        │ Parametre formatı: { "timeField":"timestamp", "timezone":8 }
        │ İşlev: Unix zaman damgasını UTC zaman dizesine dönüştürme
        ==== Özel Mod ====
        [İşlev Açıklaması]
        Uygulanacak işleme mantığını ayrıntılandırın (örneğin: "Yanıt verilerine geçerli zaman damgasını ekle")
        [Giriş Örneği]
        Orijinal Payload örneği:
        { 
          "temperature": 25, 
          "humidity": 50 
        }
        [Çıktı Gereksinimleri]
        Beklenen işlenmiş sonuç:
        { 
          "temperature": 25, 
          "humidity": 50, 
          "currentTime": "2023-10-21T14:30:00.000Z"
        }
        ==== Betik Çerçevesi ====
        /**
         * @description {İşlev Adı}
         * @param {object|string} value - Ham veri (otomatik JSON dizesi ayrıştırma)
         * @param {'publish'|'received'} msgType - Mesaj türü: 'received' veya 'publish'
         * @param {number} [index] - Mesaj dizini (yalnızca betik zamanlı mesaj ile yayın için kullanıldığında geçerli)
         */
        function handlePayload(value, msgType, index) {
          try {
            // Temel işlem mantığı ▼▼▼
            {{CORE_LOGIC}}
            // Dönüş öncesi işleme (JSON serileştirilmiş tut)
            return typeof _value === 'object' ? 
              JSON.stringify(_value, null, 2) : _value;
          } catch (e) {
            console.error('İşlem hatası:', e);
            return value; // Orijinal veriyi koru
          }
        }
        execute(handlePayload);
        ==== Oluşturma Kuralları ====
        1. Her alan değişikliği için yorumlar ekleyin
        2. Mesaj akış işleme mantığını kesin bir şekilde ayırın
        3. Sahte veri oluştururken makul dalgalanma ekleyin
        4. Eski tarayıcılarla uyumluluğu koruyun (en son JS özelliklerinden kaçının)
        5. Özel işlev, orijinal Payload örneği ve beklenen sonuç sırasında, kod bloğu formatını sağlayarak sunun
        6. Yanıtta özlü olun, uzun açıklamalardan kaçının ancak bilgi bütünlüğünü sağlayın`,
    ja: `選択したモードに基づいてMQTTXカスタム関数を生成し、予想される結果でテストケースを提供してください：
       [生成モード]
        - プリセットテンプレート高速生成
        - カスタム要件生成（要件を説明する）
        ==== プリセットテンプレート ====
        01 気象データシミュレート
        │ パラメータ形式: { "temperature":[10,30], "humidity":[20,40] }
        │ 機能: 指定されたフィールドにランダムな値を生成する
        02 動的コマンド切り替え
        │ パラメータ形式: { "field": "command", "values": ["on","off"] }
        │ 機能: メッセージインデックスに基づいて指定されたフィールド値を交互に変更する
        03 時間フォーマット処理
        │ パラメータ形式: { "timeField":"timestamp", "timezone":8 }
        │ 機能: UnixタイムスタンプをUTC時間文字列に変換する
        ==== カスタムモード ====
        [機能説明]
        実装する処理ロジックを詳しく説明する（例：「応答データに現在のタイムスタンプを追加する」）
        [入力例]
        元のペイロードサンプル:
        { 
          "temperature": 25, 
          "humidity": 50 
        }
        [出力要件]
        予想される処理結果:
        { 
          "temperature": 25, 
          "humidity": 50, 
          "currentTime": "2023-10-21T14:30:00.000Z"
        }
        ==== スクリプトフレームワーク ====
        /**
         * @description {機能名}
         * @param {object|string} value - 生データ（JSON文字列を自動解析）
         * @param {'publish'|'received'} msgType - メッセージタイプ：'received'または'publish'
         * @param {number} [index] - メッセージインデックス（スクリプトがスケジュールされたメッセージで公開に使用される場合のみ有効）
         */
        function handlePayload(value, msgType, index) {
          try {
            // コア処理ロジック ▼▼▼
            {{CORE_LOGIC}}
            // 返却前処理（JSONシリアル化を保持）
            return typeof _value === 'object' ? 
              JSON.stringify(_value, null, 2) : _value;
          } catch (e) {
            console.error('処理エラー:', e);
            return value; // 元のデータを維持
          }
        }
        execute(handlePayload);
        ==== 生成ルール ====
        1. 各フィールド変更にコメントを追加する
        2. メッセージフロー処理ロジックを厳密に区別する
        3. モックデータ生成時に合理的な変動を追加する
        4. 古いブラウザとの互換性を維持する（最新のJS機能を避ける）
        5. カスタム関数、元のペイロードサンプル、予想される結果の順に提供し、コードブロック形式を確保する
        6. 回答は簡潔にし、冗長な説明を避けるが、情報の完全性を確保する`,
    hu: `Kérem, generáljon MQTTX egyéni függvényt a kiválasztott mód alapján, és adja meg a teszteseteket a várt eredményekkel:
       [Generálási módok]
        - Előre beállított sablon gyors generálása
        - Egyéni igény generálása (követelmények leírása)
        ==== Előre beállított sablonok ====
        01 Időjárási adatok szimulálása
        │ Paraméter formátum: { "temperature":[10,30], "humidity":[20,40] }
        │ Funkció: Véletlenszerű értékek generálása a megadott mezőkhöz
        02 Dinamikus parancs kapcsoló
        │ Paraméter formátum: { "field": "command", "values": ["on","off"] }
        │ Funkció: A megadott mező értékének váltakozó módosítása az üzenet indexe alapján
        03 Időformátum feldolgozás
        │ Paraméter formátum: { "timeField":"timestamp", "timezone":8 }
        │ Funkció: Unix időbélyeg konvertálása UTC időszöveggé
        ==== Egyéni mód ====
        [Funkció leírás]
        Részletezze a megvalósítandó feldolgozási logikát (pl.: "Aktuális időbélyeg hozzáadása a válaszadatokhoz")
        [Bemenet példa]
        Eredeti Payload minta:
        { 
          "temperature": 25, 
          "humidity": 50 
        }
        [Kimenet követelmények]
        Elvárt feldolgozott eredmény:
        { 
          "temperature": 25, 
          "humidity": 50, 
          "currentTime": "2023-10-21T14:30:00.000Z"
        }
        ==== Script keretrendszer ====
        /**
         * @description {Funkció név}
         * @param {object|string} value - Nyers adat (automatikus JSON karakterlánc elemzés)
         * @param {'publish'|'received'} msgType - Üzenettípus: 'received' vagy 'publish'
         * @param {number} [index] - Üzenet index (csak akkor érvényes, ha a szkriptet közzétételre használják ütemezett üzenettel)
         */
        function handlePayload(value, msgType, index) {
          try {
            // Alap feldolgozási logika ▼▼▼
            {{CORE_LOGIC}}
            // Visszaküldés előtti feldolgozás (JSON szerializáció megtartása)
            return typeof _value === 'object' ? 
              JSON.stringify(_value, null, 2) : _value;
          } catch (e) {
            console.error('Feldolgozási hiba:', e);
            return value; // Eredeti adat megtartása
          }
        }
        execute(handlePayload);
        ==== Generálási szabályok ====
        1. Adjon megjegyzéseket minden mezőmódosításhoz
        2. Szigorúan különböztesse meg az üzenetáramlási logikát
        3. Adjon hozzá észszerű ingadozást a szimulált adatok generálásakor
        4. Tartsa fenn a kompatibilitást a régebbi böngészőkkel (kerülje a legújabb JS funkciókat)
        5. Az egyéni függvény, az eredeti Payload minta és az elvárt eredmény sorrendjében adja meg, biztosítva a kódblokk formátumot
        6. Legyen tömör a válaszban, kerülje a hosszú leírásokat, de biztosítsa az információk teljességét`,
  },
  promptCustomFunctionCustomRequirement: {
    zh: '请帮我生成一个自定义函数，包含测试用例和预期结果，描述需求：',
    en: 'Please help me generate a custom function, including test cases and expected results, describe the requirements:',
    tr: 'Lütfen bana bir özel fonksiyon oluşturma konusunda yardımcı olun, test durumlarını ve beklenen sonuçları içerir, gereksinimleri açıklayın:',
    ja: 'テストケースと期待される結果を含むカスタム関数を生成するのにお手伝いください。要件を説明してください：',
    hu: 'Segítsen egy egyedi függvény generálásában, beleértve a teszteseteket és az elvárt eredményeket, írja le az igényeket:',
  },
  schema: {
    zh: '编解码',
    en: 'Schema',
    tr: 'Şemalar',
    ja: 'スキーマ',
    hu: 'Sémák',
  },
  reportSmartHomeStatus: {
    zh: '智能家居设备状态上报',
    en: 'Smart Home Device Status Reporting',
    tr: 'Akıllı Ev Cihaz Durum Gönderimi',
    ja: 'スマートホームデバイス状態報告',
    hu: 'Intelligens otthoni eszközállapot jelentés',
  },
  industrialDeviceAlarm: {
    zh: '工业设备告警消息',
    en: 'Industrial Device Alarm Messages',
    tr: 'Endüstriyel Cihaz Alarm Mesajları',
    ja: '産業用デバイスアラームメッセージ',
    hu: 'Ipari eszköz figyelmeztetés üzenetek',
  },
  connectedCarTelemetry: {
    zh: '车联网车辆遥测数据',
    en: 'Connected Car Telemetry Data',
    tr: 'Bağlantılı Araba Telemetri Verileri',
    ja: '車載テレメトリーデータ',
    hu: 'Csatlakoztatott autó telemetria adatok',
  },
  smartMeterReadings: {
    zh: '智能电表实时读数',
    en: 'Smart Meter Real-time Readings',
    tr: 'Akıllı Sayaç Gerçek Zamanlı Okumalar',
    ja: 'スマートメーターリアルタイム読取値',
    hu: 'Okos mérőóra valós idejű értékek',
  },
  promptSchema: {
    zh: `请根据选择生成数据 Schema 和对应示例数据：
[编码格式] => [生成模式]
- 编码格式选项：Protobuf | Avro
- 生成模式选项：
  ├─ 自定义需求生成（需填写下方描述）
  └─ 预设场景快速生成：
     │ 智能家居设备状态上报
     │ 工业设备告警消息
     │ 车联网车辆遥测数据
     │ 智能电表实时读数
==== 自定义模式 ====
详细说明数据结构需求（如："包含带状态的传感器数据，要求时间戳精度到毫秒"），可以提供示例字段数据，以便更好地理解需求
==== 预设场景特征 ====
▶ 智能家居设备状态上报
  - 必选字段：device_id（字符串）、status（枚举）、temperature（带波动范围）
  - 可选扩展：在线状态、固件版本、信号强度
▶ 工业设备告警消息
  - 必选字段：alarm_code（整型）、severity（枚举）、timestamp（时间戳）
  - 可选扩展：设备坐标、关联工单号、恢复建议
▶ 车联网车辆遥测数据
  - 必选字段：vin（字符串）、gps（坐标对象）、speed（带波动数值）
  - 可选扩展：剩余电量、胎压数组、驾驶模式
▶ 智能电表实时读数
  - 必选字段：meter_id（定长字符串）、voltage（带精度数值）、timestamp（ISO8601）
  - 可选扩展：相位不平衡度、异常事件标志位
==== 生成规则 ====
1. Protobuf 输出顺序：
   ▼ 完整的 .proto 文件，包含语法声明如 syntax = "proto3";
   ▼ 数据类型名称（如：类型名称：DeviceStatusReport）
   ▼ 输入示例数据
   
   // 示例结构
   ## Schema
   当前 Schema 的描述，说明重要字段的作用（使用markdown普通段落）
   syntax = "proto3";
   message DeviceReport {
     string device_id = 1;
     int32 value = 2;
     string firmware = 3;
   }
   
   ## 类型名称(使用markdown代码块格式)
   DeviceReport
   
   ## 示例数据
   {
     "device_id": "dev12345",
     "value": 100,
     "firmware": "1.0.0"
   }
   
2. Avro 输出顺序：
   ▼ 完整的 .avsc 文件
   ▼ 输入示例数据
   
   // 示例结构
   ## Schema
   当前 Schema 的描述，说明重要字段的作用（使用markdown普通段落）
   {
     "type": "record",
     "name": "Person",
     "fields": [
       {"name": "id", "type": "int"},
       {"name": "name", "type": "string"}
     ]
   }
==== 注意事项 ====
1. Protobuf特别要求：
   - 枚举值必须使用整数值，示例数据中必须使用枚举对应的整数值（如：status: 2）
2. 提供JSON格式的保证示例数，并保证示例数据包含Schema中定义的所有字段，字段名称完全一致，不能有任何遗漏
3. 所有代码和数据必须使用markdown代码块格式输出，便于复制和查看
选择的编码格式：{0}`,

    en: `Please generate data Schema and corresponding sample data based on your selection:
[Encoding Format] => [Generation Mode]
- Encoding Format Options: Protobuf | Avro
- Generation Mode Options:
  ├─ Custom Requirements (please fill in description below)
  └─ Preset Scenarios for Quick Generation:
     │ Smart Home Device Status Report
     │ Industrial Equipment Alarm Message
     │ Connected Vehicle Telemetry Data
     │ Smart Meter Real-time Readings
==== Custom Mode ====
Please provide detailed data structure requirements (e.g., "include sensor data with status, require millisecond timestamp precision"), you can provide sample field data to better understand your needs
==== Preset Scenario Features ====
▶ Smart Home Device Status Report
  - Required fields: device_id (string), status (enum), temperature (with fluctuation range)
  - Optional extensions: online status, firmware version, signal strength
▶ Industrial Equipment Alarm Message
  - Required fields: alarm_code (integer), severity (enum), timestamp (timestamp)
  - Optional extensions: device coordinates, related work order number, recovery suggestions
▶ Connected Vehicle Telemetry Data
  - Required fields: vin (string), gps (coordinate object), speed (fluctuating value)
  - Optional extensions: remaining battery, tire pressure array, driving mode
▶ Smart Meter Real-time Readings
  - Required fields: meter_id (fixed-length string), voltage (value with precision), timestamp (ISO8601)
  - Optional extensions: phase imbalance, anomaly event flags
==== Generation Rules ====
1. Protobuf Output Order:
   ▼ Complete .proto file, including syntax declaration like syntax = "proto3";
   ▼ Data type name (e.g., Type name: DeviceStatusReport)
   ▼ Sample input data
   
   // Example structure
   ## Schema
   Description of the current Schema, explaining the purpose of important fields (use markdown plain paragraph)
   syntax = "proto3";
   message DeviceReport {
     string device_id = 1;
     int32 value = 2;
     string firmware = 3;
   }
   
   ## Type name (use markdown code block format)
   DeviceReport
   
   ## Sample data
   {
     "device_id": "dev12345",
     "value": 100,
     "firmware": "1.0.0"
   }
   
2. Avro Output Order:
   ▼ Complete .avsc file
   ▼ Sample input data
   
   // Example structure
   ## Schema
   Description of the current Schema, explaining the purpose of important fields (use markdown plain paragraph)
   {
     "type": "record",
     "name": "Person",
     "fields": [
       {"name": "id", "type": "int"},
       {"name": "name", "type": "string"}
     ]
   }
==== Notes ====
1. Protobuf Special Requirements:
   - Enum values must use integer values, sample data must use the corresponding integer value for enums (e.g., status: 2)
2. Provide sample data in JSON format, ensuring all fields defined in the Schema are included, field names match exactly, with no omissions
3. All code and data must be output in markdown code block format for easy copying and viewing
Selected encoding format: {0}`,

    ja: `選択に基づいてデータスキーマと対応するサンプルデータを生成します：
[エンコード形式] => [生成モード]
- エンコード形式オプション：Protobuf | Avro
- 生成モードオプション：
  ├─ カスタム要件生成（下記に詳細を記入）
  └─ プリセットシナリオ：
     │ スマートホームデバイスステータスレポート
     │ 産業機器アラームメッセージ
     │ コネクテッドカーテレメトリーデータ
     │ スマートメーターリアルタイム読取値
==== カスタムモード ====
データ構造要件を詳細に説明してください（例：「ステータス付きのセンサーデータを含み、タイムスタンプはミリ秒精度が必要」）。サンプルフィールドデータを提供すると要件の理解が進みます
==== プリセットシナリオの特徴 ====
▶ スマートホームデバイスステータスレポート
  - 必須フィールド：device_id（文字列）、status（列挙型）、temperature（変動範囲付き）
  - オプション拡張：オンラインステータス、ファームウェアバージョン、信号強度
▶ 産業機器アラームメッセージ
  - 必須フィールド：alarm_code（整数型）、severity（列挙型）、timestamp（タイムスタンプ）
  - オプション拡張：デバイス座標、関連作業指示番号、復旧提案
▶ コネクテッドカーテレメトリーデータ
  - 必須フィールド：vin（文字列）、gps（座標オブジェクト）、speed（変動値）
  - オプション拡張：残りバッテリー、タイヤ空気圧配列、運転モード
▶ スマートメーターリアルタイム読取値
  - 必須フィールド：meter_id（固定長文字列）、voltage（精度付き値）、timestamp（ISO8601）
  - オプション拡張：相不均衡度、異常イベントフラグ
==== 生成ルール ====
1. Protobuf 出力順序：
   ▼ 完全な .proto ファイル（syntax = "proto3"; などの構文宣言を含む）
   ▼ データ型名（例：型名：DeviceStatusReport）
   ▼ サンプル入力データ
   
   // 例構造
   ## スキーマ
   現在のスキーマの説明，重要なフィールドの役割を解説してください（markdownの通常の段落形式を使用）
   syntax = "proto3";
   message DeviceReport {
     string device_id = 1;
     int32 value = 2;
     string firmware = 3;
   }
   
   ## 型名(マークダウンコードブロック形式使用)
   DeviceReport
   
   ## サンプルデータ
   {
     "device_id": "dev12345",
     "value": 100,
     "firmware": "1.0.0"
   }
   
2. Avro 出力順序：
   ▼ 完全な .avsc ファイル
   ▼ サンプル入力データ
   
   // 例構造
   ## スキーマ
   現在のスキーマの説明，重要なフィールドの役割を解説してください（markdownの通常の段落形式を使用）
   {
     "type": "record",
     "name": "Person",
     "fields": [
       {"name": "id", "type": "int"},
       {"name": "name", "type": "string"}
     ]
   }
==== 注意事項 ====
1. Protobuf特別要件：
   - 列挙値は整数値を使用し、サンプルデータでは列挙に対応する整数値を使用すること（例：status: 2）
2. JSONフォーマットでサンプルデータを提供し、スキーマで定義されたすべてのフィールドが含まれ、フィールド名が完全に一致し、省略がないようにすること
3. すべてのコードとデータはマークダウンコードブロック形式で出力し、コピーと表示を容易にすること
選択したエンコード形式: {0}`,

    tr: `Seçiminize göre veri Şeması ve karşılık gelen örnek veriler oluşturun:
[Kodlama Formatı] => [Oluşturma Modu]
- Kodlama Formatı Seçenekleri: Protobuf | Avro
- Oluşturma Modu Seçenekleri:
  ├─ Özel Gereksinim Oluşturma (lütfen aşağıdaki açıklamayı doldurun)
  └─ Hazır Senaryolar:
     │ Akıllı Ev Cihazı Durum Raporu
     │ Endüstriyel Ekipman Alarm Mesajı
     │ Bağlantılı Araç Telemetri Verileri
     │ Akıllı Sayaç Gerçek Zamanlı Okumaları
==== Özel Mod ====
Veri yapısı gereksinimlerinizi detaylı olarak açıklayın (örn: "durumlu sensör verilerini içerir, zaman damgası milisaniye hassasiyetinde olmalıdır"), gereksinimlerinizin daha iyi anlaşılması için örnek alan verileri sağlayabilirsiniz
==== Hazır Senaryo Özellikleri ====
▶ Akıllı Ev Cihazı Durum Raporu
  - Zorunlu alanlar: device_id (dize), status (enum), temperature (dalgalanma aralığı ile)
  - Opsiyonel uzantılar: çevrimiçi durumu, yazılım sürümü, sinyal gücü
▶ Endüstriyel Ekipman Alarm Mesajı
  - Zorunlu alanlar: alarm_code (tamsayı), severity (enum), timestamp (zaman damgası)
  - Opsiyonel uzantılar: cihaz koordinatları, ilgili iş emri numarası, kurtarma önerileri
▶ Bağlantılı Araç Telemetri Verileri
  - Zorunlu alanlar: vin (dize), gps (koordinat nesnesi), speed (dalgalanan değer)
  - Opsiyonel uzantılar: kalan batarya, lastik basıncı dizisi, sürüş modu
▶ Akıllı Sayaç Gerçek Zamanlı Okumaları
  - Zorunlu alanlar: meter_id (sabit uzunlukta dize), voltage (hassasiyetli değer), timestamp (ISO8601)
  - Opsiyonel uzantılar: faz dengesizliği, anormal olay bayrakları
==== Oluşturma Kuralları ====
1. Protobuf Çıktı Sırası:
   ▼ syntax = "proto3"; gibi sözdizimi beyanını içeren tam .proto dosyası
   ▼ Veri türü adı (örn: Tür adı: DeviceStatusReport)
   ▼ Örnek girdi verileri
   
   // Örnek yapı
   ## Şema
   Geçerli Şema'nın açıklaması, önemli alanların amacını açıklayın (markdown normal paragraf biçimini kullanın)
   syntax = "proto3";
   message DeviceReport {
     string device_id = 1;
     int32 value = 2;
     string firmware = 3;
   }
   
   ## Tür adı (markdown kod bloğu formatını kullanın)
   DeviceReport
   
   ## Örnek veri
   {
     "device_id": "dev12345",
     "value": 100,
     "firmware": "1.0.0"
   }
   
2. Avro Çıktı Sırası:
   ▼ Tam .avsc dosyası
   ▼ Örnek girdi verileri
   
   // Örnek yapı
   ## Şema
   Geçerli Şema'nın açıklaması, önemli alanların amacını açıklayın (markdown normal paragraf biçimini kullanın)
   {
     "type": "record",
     "name": "Person",
     "fields": [
       {"name": "id", "type": "int"},
       {"name": "name", "type": "string"}
     ]
   }
==== Notlar ====
1. Protobuf Özel Gereksinimleri:
   - Enum değerleri tamsayı değerleri kullanmalı, örnek veriler enum'lara karşılık gelen tamsayı değerlerini kullanmalıdır (örn: status: 2)
2. JSON formatında örnek veriler sağlayın ve Şemada tanımlanan tüm alanların dahil edildiğinden, alan adlarının tam olarak eşleştiğinden ve hiçbir eksiklik olmadığından emin olun
3. Tüm kod ve veriler, kolay kopyalama ve görüntüleme için markdown kod bloğu formatında çıktılanmalıdır
Seçilen kodlama formatı: {0}`,

    hu: `Kérjük, hozzon létre adatsémát és megfelelő mintaadatokat a kiválasztás alapján:
[Kódolási formátum] => [Generálási mód]
- Kódolási formátum opciók: Protobuf | Avro
- Generálási mód opciók:
  ├─ Egyéni követelmények generálása (kérjük, töltse ki az alábbi leírást)
  └─ Előre beállított forgatókönyvek:
     │ Okosotthon eszköz állapotjelentés
     │ Ipari berendezés riasztási üzenet
     │ Hálózatba kapcsolt jármű telemetriai adatok
     │ Okos mérőóra valós idejű leolvasások
==== Egyéni mód ====
Részletesen írja le az adatszerkezeti követelményeket (pl.: "tartalmaz állapottal rendelkező szenzor adatokat, milliszekundum pontosságú időbélyeg szükséges"), megadhat minta mezőadatokat a követelmények jobb megértéséhez
==== Előre beállított forgatókönyv jellemzők ====
▶ Okosotthon eszköz állapotjelentés
  - Kötelező mezők: device_id (sztring), status (felsorolás), temperature (ingadozási tartománnyal)
  - Opcionális kiterjesztések: online állapot, firmware verzió, jelerősség
▶ Ipari berendezés riasztási üzenet
  - Kötelező mezők: alarm_code (egész szám), severity (felsorolás), timestamp (időbélyeg)
  - Opcionális kiterjesztések: eszköz koordináták, kapcsolódó munkarendelési szám, helyreállítási javaslatok
▶ Hálózatba kapcsolt jármű telemetriai adatok
  - Kötelező mezők: vin (sztring), gps (koordináta objektum), speed (ingadozó érték)
  - Opcionális kiterjesztések: maradék akkumulátor, gumiabroncs nyomás tömb, vezetési mód
▶ Okos mérőóra valós idejű leolvasások
  - Kötelező mezők: meter_id (fix hosszúságú sztring), voltage (pontossággal rendelkező érték), timestamp (ISO8601)
  - Opcionális kiterjesztések: fázis egyensúlytalanság, anomália esemény jelzők
==== Generálási szabályok ====
1. Protobuf kimeneti sorrend:
   ▼ Teljes .proto fájl, beleértve a szintaxis deklarációt, mint syntax = "proto3";
   ▼ Adattípus neve (pl.: Típus neve: DeviceStatusReport)
   ▼ Minta bemeneti adatok
   
   // Példa struktúra
   ## Séma
   A jelenlegi séma leírása, amely ismerteti a fontos mezők szerepét (markdown sima bekezdést használjon)
   syntax = "proto3";
   message DeviceReport {
     string device_id = 1;
     int32 value = 2;
     string firmware = 3;
   }
   
   ## Típus neve (markdown kódblokk formátumban)
   DeviceReport
   
   ## Minta adatok
   {
     "device_id": "dev12345",
     "value": 100,
     "firmware": "1.0.0"
   }
   
2. Avro kimeneti sorrend:
   ▼ Teljes .avsc fájl
   ▼ Minta bemeneti adatok
   
   // Példa struktúra
   ## Séma
   A jelenlegi séma leírása, amely ismerteti a fontos mezők szerepét (markdown sima bekezdést használjon)
   {
     "type": "record",
     "name": "Person",
     "fields": [
       {"name": "id", "type": "int"},
       {"name": "name", "type": "string"}
     ]
   }
==== Megjegyzések ====
1. Protobuf speciális követelmények:
   - A felsorolás értékeknek egész számokat kell használniuk, a mintaadatokban a felsorolásoknak megfelelő egész számértékeket kell használni (pl.: status: 2)
2. Biztosítson JSON formátumú mintaadatokat, és győződjön meg arról, hogy a Sémában definiált összes mező szerepel, a mezőnevek pontosan egyeznek, nincsenek kihagyások
3. Minden kódot és adatot markdown kódblokk formátumban kell kimenetre küldeni a könnyű másolás és megtekintés érdekében
Választott kódolási formátum: {0}`,
  },
  promptSchemaCustomRequirement: {
    zh: '请根据需求生成对应的数据 Schema 和示例数据，描述需求：',
    en: 'Please generate the corresponding data schema and example data according to the requirements, describe the requirements:',
    tr: 'lütfen gereksinimlere göre karşılık gelen veri şemasını ve örnek verileri oluşturun, gereksinimleri açıklayın:',
    ja: '要件に従って対応するデータスキーマと例示データを生成してください。要件を説明してください：',
    hu: 'kérem generálja a megfelelő adatsémát és példaadatokat az igényeknek megfelelően, írja le az igényeket:',
  },
}
